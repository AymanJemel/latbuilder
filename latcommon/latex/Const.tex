% Copyright (c) 2012 Richard Simard, Pierre L'Ecuyer, Université de Montréal.
% 
% This file is part of Lattice Builder.
% 
% Lattice Builder is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation, either version 3 of the License, or
% (at your option) any later version.
% 
% Lattice Builder is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with Lattice Builder.  If not, see <http://www.gnu.org/licenses/>.

\defmodule {Const}

This module contains global constants used in
\latmrg{} and \latbuild. 
\richard{Most of these are used only in
\latmrg; thus should separate this in two different files:
one common and one in \latmrg.}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bigskip\hrule
\code\hide
#ifndef CONST_H
#define CONST_H
\endhide
#include <string>


namespace LatCommon {


enum NormType { SUPNORM, L1NORM, L2NORM, ZAREMBANORM };
\endcode
\tab
Indicates which norm is used to measure the length of vectors.
For $X = (x_1,\dots,x_t)$,
\endtab
\tabb
\texttt{SUPNORM} corresponds to $\Vert X\Vert = \max (|x_1|,\dots,|x_t|)$.\\[1ex]
\texttt{L1NORM}  corresponds to $\Vert X\Vert = |x_1|+\cdots+|x_t|$.\\[1ex]
\texttt{L2NORM} corresponds to  $\Vert X\Vert = (x_1^2+\cdots+x_t^2)^{1/2}$.\\[1ex]
\texttt{ZAREMBANORM} corresponds
   to  $\Vert X\Vert = \max(1, |x_1|)\cdots\max(1, |x_t|)$.
\endtabb
\code


enum GenType { LCG, MRG, MWC, KOROBOV, RANK1 };
\endcode
\tab
Used to identify the type of a generator. If a generator is of type \texttt{MWC},
it is converted to its corresponding \texttt{MRG} by the program.
\endtab
\tabb   \texttt{LCG}: the linear congruential generator.\\[1ex]
  \texttt{MRG}: the multiple-recursive generator.\\[1ex]
  \texttt{MWC}: the multiply-with-carry generator.\\[1ex]
  \texttt{KOROBOV}: the Korobov lattice.\\[1ex]
  \texttt{RANK1}: the rank 1 lattice.
\endtabb
\code

   
enum LatticeType { FULL, RECURRENT, ORBIT, PRIMEPOWER };
\endcode
\tab
Indicates whether to analyze the lattice generated by all possible states,
  or a sub-lattice generated by the set of recurrent states or by a
  sub-cycle of the generator.
\endtab
\tabb
 \texttt{FULL}: The complete lattice, generated by all possible
     initial states, will be analyzed.\\[1ex]
  \texttt{RECURRENT}: If the (combined) generator has transient
     states, then the lattice analyzed will be the sub-lattice generated by
     the set of recurrent states.\\[1ex]
 \texttt{ORBIT}: The grid generated by the (forward) orbit of 
     a state of the (combined) generator is analyzed. This state
     is specified as follows. 
     On the following $J$ lines, the initial state for each
     component must be given. This is an integer vector with a number 
     of components equal to the order of the component.\\[1ex]
  \texttt{PRIMEPOWER}: In the case where some component is an MLCG
     whose modulus is a power of a prime $p$, then the states visited over
     a single orbit (sub-cycle) of that component generate a sub-lattice
     (when $a \equiv 1 \bmod{p}$) or belong to the union of
     $p-1$ sub-lattices (otherwise).  If \texttt{LatticeType} takes this value,
     and a component is a MLCG ($k=1$), 
     and if the modulus of that MLCG is given
     in the data file in the form (b): $(x\ y\ z)$ with $z=0$ and $x$ prime, 
     then what is analyzed
     is one of those sub-lattices.  This is done by dividing the modulus
     by the appropriate power of $p$, as described in \cite{rLEC94e}.
     For example, if $p=2$ and $a \mod 8 = 5$, then the modulus is divided
     by 4 as in \cite{rFIS90a,rKNU81a}.
\endtabb
\code

          
enum PrimeType { UNKNOWN, PRIME, PROB_PRIME, COMPOSITE };
\endcode
\tab
Indicates whether an integer is prime, probably prime, composite or its 
status is unknown (or don't care).
\endtab
\code

          
enum DecompType { DECOMP, DECOMP_WRITE, DECOMP_READ, DECOMP_PRIME };
\endcode
\tab
Given an integer $r$, indicates what to do about the decomposition of $r$ in
its prime factors.
\endtab
\tabb
 \texttt{DECOMP}: means that the program will factorize $r$.\\[1ex]
 \texttt{DECOMP\_WRITE}: means that the program will factorize $r$ and
    writes the factors in a file.\\[1ex]
 \texttt{DECOMP\_READ}: means that $r$ is already factorized, and
    the factors will be read from a file.\\[1ex]
 \texttt{DECOMP\_PRIME}: means that $r$ is prime. 
  No factorization will be done.
\endtabb
\code


enum OutputType { TERMINAL, RES, TEX, GEN };
\endcode
\tab
Indicates in which form and where the results will be sent. \label{co:output}
\endtab
\tabb
 \texttt{TERMINAL}: the results will appear only on the terminal screen.\\[1ex]
 \texttt{RES}: the results will be in plain text format and sent to a file with
 extension ``\texttt{.res}''.\\[1ex]
 \texttt{TEX}:  the results will be in \LaTeX{} format and sent to a file with
 extension ``\texttt{.tex}''.\\[1ex]
 \texttt{GEN}:  the results will be sent to a file with
 extension ``\texttt{.gen}''.
\endtabb
\code


enum CriterionType { SPECTRAL, BEYER, PALPHA, BOUND_JS };
\endcode
\tab
Gives the merit criterion for ranking generators or lattices.
\endtab
\tabb   \texttt{BEYER}: the figure of merit is the Beyer quotient $Q_T$.\\[1ex]
\texttt{SPECTRAL}: the figure of merit $S_T$ is based on the spectral test.\\[1ex]
\texttt{PALPHA}: the figure of merit is based on $P_\alpha$.\\[1ex]
\texttt{BOUND\_JS}: the figure of merit is based on the Joe-Sinescu bound
 \cite{rSIN08a}.
\endtabb
\code


enum NormaType { BESTLAT, LAMINATED, ROGERS, MINKOWSKI, MINKL1,
                 PALPHA_N, NORMA_GENERIC };
\endcode
\tab
 Indicates which normalization is used to compute
 $S_t$ in the spectral test, for each dimension $t$.
\endtab
\tabb
  \texttt{BESTLAT}: the value used for $d_t^*$ corresponds to 
   the best lattice.\\[1ex]
 \texttt{LAMINATED}: the value used for $d_t^*$ corresponds to 
  the best \emph{laminated} lattice.\\[1ex]
 \texttt{ROGERS}:  the value for $d_t^*$ is obtained from \emph{Rogers'} bound
  on the density of sphere packing.\\[1ex]
 \texttt{MINKOWSKI}: the value for $d_t^*$ is obtained from \emph{Minkowski'}
 theoretical bounds on the length of the shortest nonzero vector in the lattice
 using the ${\cal L}_2$ norm.\\[1ex]
 \texttt{MINKL1}: the value for $d_t^*$ is obtained from the theoretical bounds on
 the length of the shortest nonzero vector in the lattice using the ${\cal L}_1$
 norm.\\[1ex]
  \texttt{PALPHA\_N}: the case of the $P_\alpha$ test.\\[1ex]
  \texttt{NORMA\_GENERIC}: the trivial normalization (= 1) used for the generic
  case when no useful normalization constant is known. 
\endtabb
\code


enum CalcType { PAL, NORMPAL, BAL, SEEKPAL };
\endcode
\tab
Indicates which type of calculation is considered for the $P_\alpha$ test.
\label{CalcType.def}
\endtab
\tabb
\texttt{PAL} is for the $P_\alpha$ test. \\[1ex]
\texttt{BAL} is for the bound on the $P_\alpha$ test. \\[1ex] 
\texttt{NORMPAL} is for the $P_\alpha$ test \texttt{PAL}, with the result 
normalized over the \texttt{BAL} bound. \\[1ex]
\texttt{SEEKPAL} is for the $P_\alpha$ seek, which searches for good values
  of the multiplier.
\endtabb
\code


enum ImplemCond { NO_COND, APP_FACT, POWER_TWO, EQUAL_COEF, ZERO_COEF };
\endcode
\tab
  Indicates which type of conditions are imposed
  on the coefficients $a_i$ of a recurrence.
\endtab
\tabb
  \texttt{NO\_COND}:  no condition is imposed on the coefficients.\\[1ex]
  \texttt{APP\_FACT}: the coefficients must satisfy the ``approximate factoring''
  condition $|a_i| (m\mod |a_i|) < m$. Congruential generators are easier to
  implement under this condition \cite{rLEC90a}.\\[1ex]
  \texttt{POWER\_TWO}: the coefficients must be sums or differences of powers
   of 2.\\[1ex]
 \texttt{EQUAL\_COEF}: all the coefficients must be equal by groups:
    a first group all equal to a first number, a second group all equal to a
    second number, and so on. \\[1ex]
 \texttt{ZERO\_COEF}: all the coefficients must be equal to 0, except for a
   select fews.
\endtabb
\code


enum SearchMethod { EXHAUST, RANDOM };
\endcode
\tab
 Indicates the search method used to find good multipliers $a_i$.
\endtab
\tabb
  \texttt{EXHAUST}:  the search will be exhaustive over the chosen regions.\\[1ex]
  \texttt{RANDOM}:  the search will be random over the chosen regions.
\endtabb


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\guisec{toString functions}

Useful functions for printing the \texttt{enum} constants in this module.
\code

std::string toStringNorm (NormType);
std::string toStringGen (GenType);
std::string toStringLattice (LatticeType);
std::string toStringPrime (PrimeType);
std::string toStringDecomp (DecompType);
std::string toStringOutput (OutputType);
std::string toStringCriterion (CriterionType);
std::string toStringNorma (NormaType);
std::string toStringCalc (CalcType);
std::string toStringImplemCond (ImplemCond);
std::string toStringSearchMethod (SearchMethod);
\endcode
\tab
Returns the \texttt{enum} constants in this module as strings. 
\richard{These are global methods for now, but maybe \texttt{Const} should be a
 class containing these methods.}
\endtab
\code

}
\hide
#endif
\endhide
\endcode
